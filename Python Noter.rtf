{\rtf1\ansi\ansicpg1252\cocoartf1671\cocoasubrtf600
{\fonttbl\f0\fswiss\fcharset0 Helvetica-Bold;\f1\fswiss\fcharset0 Helvetica;\f2\fswiss\fcharset0 Helvetica-Oblique;
}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;}
\paperw11900\paperh16840\margl1440\margr1440\vieww14780\viewh15600\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\b\fs40 \cf0 Basics (Exercises)\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\sl288\slmult1\pardirnatural\partightenfactor0

\fs24 \cf0 \

\fs28 Importing:\

\f1\b0\fs24 \ul Numpy:\ulnone  import numpy as np\
\ul matplotlib:\ulnone  import matplotlib.pyplot as plt\
\ul pandas:\ulnone  import pandas as pd\
\ul csv.files:\ulnone  \cf2 variable_name = pd.DataFrame(pd.read_csv(\'91filnavn.csv\'92)
\f0\b\fs28 \cf0 \
\
Atomic TYPES:
\f1\b0\fs24 \
Bool: True or false\
Int: Numbers\
float: int + irrationelt tal (bare tal med decimal)\
string: tekst\
\

\f0\b\fs28 Containers (Other type): Can contain atomic types
\f1\b0\fs24 \

\f0\b \cf2 Lister: []
\f1\b0  \cf0 Kan have alle slags types\cf2 \
subsetting: udtr\'e6k af listerne, fx. my_list[2] (v\'e6lger andet element i listen)\
slicing: my_list[start(inkl.):end(ekskl.)]\
manipulation: tilf\'f8je eller fjerne elementer i lister\
	del(mylist[4]) (sletter elementet)\
	mylist[2] = \'93john\'94 (\'e6ndrer elementet)\
	mylist + [\'93john\'94, 2] (tilf\'f8jer elementer til listen)\
len: length of list - number of elements it contains\
Referencing: Hvis man har en liste, x, kan man lave en ny liste, y=x. Hvis man \'e6ndrer y, \'e6ndrer man ogs\'e5 x. x og y refererer alts\'e5 til det samme objekt. Hvis man sletter x, findes y alts\'e5 stadig, og den refererer til samme baseliste. \
Copy: Alternativ til referencing; her har man fx y, en kopi af x; men hvis man \'e6ndrer i y \'e6ndrer man nu ikke i baselisten, x.\
Deepcopy: Den originale liste, f\'f8r man \'e6ndrer i den, mens alm. copy i visse tilf\'e6lde kan \'e6ndres (se F2)\
\

\f0\b Tuples: () 
\f1\b0 Lister, der ikke kan \'e6ndres. Laves med () i stedet for []\
\

\f0\b Dictionaries: \{\}
\f1\b0  key-based i stedet for index-based container. Keys: Alle objekter, der ikke kan \'e6ndres. Man kan fylde dictionary med v\'e6rdier, der kan hentes med forskellige keys.\
\

\f0\b Kommandoer:
\f1\b0 \
Convertion: Alle atomic types kan konverteres til andre; int(y) konverterer y til et integer (runder altid ned!)\
	- OBS: Hvis man dividerer (/) bliver alle integers til floats - hvis man vil have integer skal man bruge (//) - den runer ned!\
Try/Except: Fors\'f8g noget, hvis fejl findes, g\'f8r noget andet (fx print(\'93fejl\'94))\
Operators: +,-,/,//(division rundet ned til int),*,**(potens)\
Augmentation: +=,-=,*=,/=: \'c6ndrer l\'f8bende v\'e6rdien. += till\'e6gger den gamle v\'e6rdi\
Comparisons: ==,!=, <,<=,>,>=: Compares values, returns booleans (true/false)\
List.Append(x**2): \'e6ndrer noget i listen, her alle elementer i anden potens\
\

\f0\b Conditionals
\f1\b0 : if/elif/else: \
	if noget: det her sker\
	elif noget andet: det her sker\
	else: Det her sker\
- not: noget sker ikke\
- and: noget sker ogs\'e5\
\
\ul try/except: \ulnone Try something, and do something if this isn\'92t possible. \
try: \
	print(data)\
except: \
	print(\'91data doesn\'92t exist.\'92)\
\
\

\f0\b Loops: 
\f1\b0 Noget, der skal gentages. \
	for loop: for noget (en HEL collection), g\'f8r noget\
		range(x): giver alle int\'92s op til x\
	while loop: N\'e5r noget g\'e6lder, fx x< 4, g\'f8r noget\
	enumerate() loop: \
	continue: Go to next iteration\
	break: Stop loop prematurely\
	\

\f0\b Funktioner:
\f1\b0  Er objekter. Liste af kommandoer, der udf\'f8res. Kan godt indeholde v\'e6rdier i stedet for variable\
Scope for variable kan enten v\'e6re local eller global. Hvis fx. funktionen arbejder med a, s\'e5 er a globalt hvis den defineres uden for funktionen, og den er lokal hvis den defineres inden i funktionen. Lokale variable overg\'e5r globale. Hvis samme er defineret begge steder g\'e6lder den lokale.\
	def f(x,a=2): return x**2\
	alts\'e5 def funktionsnavn(variable og krav): return (hvad er funktionens output)\
overflow: N\'e5r tallet bliver stort, output er inf\
underflow: N\'e5r tallet bliver sm\'e5t, output er nan\
Funktioner:\
	Max(): Giver den st\'f8rste v\'e6rdi i listen\
	Min(): Giver laveste v\'e6rdi\
	Sorted(): Sorterer listen\
\

\f0\b Methods: 
\f1\b0 Alt i Python er objekter. Alle objekter af forskellige typer har forskellige methods (fx. strings, lists, bools, ints, etc.). OBS: Nogle methods \'e6ndrer d\'e9n liste, de kaldes p\'e5, mens nogle ikke g\'f8r. Hvis de \'e6ndrer listen, s\'e5 husk at definere en ny variabel. \
	\'93list\'94.index(): Fort\'e6ller, hvilket nummer objekt i listen objektet er\
	\'93list\'94.count(): Giver antallet af objekter i listen\
	\'93list\'94.append(): Tilf\'f8jer element til listen\
\

\f0\b Classes:
\f1\b0  Basically, types are classes. Man kan definere sin egen class. Kan defineres og till\'e6gges attributes:\
	class human(): \
\

\f0\b Numpy: 
\f1\b0 Using Python to solve numerical problems. Numpy 
\f2\i array
\f1\i0  er ligesom en liste, men med to forskelle: 1) Elementer skal v\'e6re af homogen type. 2) Slices returner et view i stedet for et extract (?).\
Man skal altid huske at import nympy as np (importere det f\'f8rst og s\'e5 kalde det np). Derefter kan man bruge numpy ved fx. np.array[]\
- Indexing. You can index by rows and columns. There are also logical operators. & is \'91and\'92, | is \'91or\'92.\
- Arrays: 2D-lister med lister. Kan kaldes ved np.array([nummer,row:column,nummer])\
\
\ul Matplotlib:
\f0\b \ulnone  
\f1\b0 Plotting in Python:\
\ul Plots:\ulnone \
Import matplotlib.pyplot as plt. \
plt.plot(X-axis,Y-axis)\
plt.log(x-scale) (Hvordan logger man?)\
plt.show()\
plt.scatter(x_variabel, y_variabel, 	s(ize) = z_variabel, 	c = color, alpha=0.8(betw. 0 and 1, transparency))\
plt.grid(True): Gives grids\
color: made with dictionary = \{\'91Asia\'92:\'92red\'92,\'92Europe\'92:\'92green\'92,\'85\}\
plt.xlabel(\'91navn\'92)\
plt.title(\'91titel\'92)\
plt.yticks([0,2,4,6,8],[\'910B\'92,\'922B\'92,\'924B\'92,\'926B\'92,\'928B\'92]): sets the number of ticks, and names them if needed in second list. \
\
\ul Histograms:\ulnone \
Bins: Values are divided into number of bins\
plt.hist(variabel, bins=x)\
plt.clf renders everything nicely\
\
\ul Dictionaries:\ulnone  Unordered. dict = \{\'91key1\'92:value1,\'92key2\'92:\'92value2\}. Dictionaries can contain other dictionaries in values\
dict[value]\
Europe.keys() gives all the keys (first elements) \
Europe(\'91Norway\'92) prints element connected to Norway\
if the same key is assigned twice, the latest value is the result\
keys are immutable objects - therefore, lists can\'92t be keys.\
del(World[\'92Sealand\'92]) deletes Sealand from dictionary World\
Europe[\'91Iceland\'92] = \'91Reykjavik\'92 (adds keys and values to dictionary)\
\
\ul Pandas: \ulnone Based on NumPy, but more high-level. Can contain different types. Library of good data structures - DataFrame the best.\
Storing data with labeling of rows and columns. \
import pandas as pd\
my_dict = \{\'92key\'92:value,\'85\}\
variable = pd.DataFrame(my_dict) (sets dictionary in dataframe)\
index_variables = [\'91john1\'92, \'91john2\'92,\'85]\
variable.index = index_variables \
Importing CSV-files: variable_name = pd.DataFrame(pd.read_csv(\'91filnavn.csv\'92), index.col=kolonnenummer der skal l\'e6ses som r\'e6kkelabel)\
Column access: \
	variable[[\'93s\'f8je_fra\'94, \'93s\'f8jle_til\'94]]\
Row acces:  (loc is label-based, so draws information from column/row labels, while iloc is index-based, draws from integer-indexes)\
	Variable[r\'e6kke_fra:r\'e6kke_til]\
	variable.loc[\'93r\'e6kkenavn\'94] (gives row as Panda series (vertical)) OR variable.loc[[\'93r\'e6kkenavn]] (gives row as DataFrame - horisontal)\
	variable.loc[[\'93r\'e6kke_fra\'94,\'94r\'e6kke_til\'94], [\'93s\'f8jle_fra\'94,\'94s\'f8jle_til\'94]] (gives overlapping data in cross-section) (:,x gives all rows, but column x) (x,: gives row x all columns)\
	variable.iloc[[1,2]] gives row 2 and 3 in data\
	iloc and loc can be combined by \'91ix\'92 - when using both label and integer-based indexing.\
Filtering: you can compare pandas by comparison statements, defining new pandas. These can then be called as pandaname[new_sub-panda], fx:\
Large = brics[\'93area\'94] > 8\
brics[Large] gives a new sub-panda with new observations\
\
\ul Comparison statements:\
\ulnone >,<,==,=!,<=,>=,\ul \
\ulnone Strings will be evaluated on alphabetical order, not number of characters.\ul \
\
Boolean operators:\ulnone \
- And (all must be true for true)\
- Or (one must be true for true)\
- Not (Negates)\
- The following are the same, possible to use for Numpy\
	np.logical_and(x>10,x>=2)\
	np.logical_or()\
	np.logical_not()\
\
\ul Conditional statements\ulnone :\ul \
\ulnone if-statements: If the criteria here works:\
	then execute all indented stuff here.\
elif: Another condition for something else, there can be infinite elifs:\
	then print this	\
else: \
	In any other case where if-statement doesn\'92t hold, this is executed\
\
\ul While loops:\ulnone  repeated if-statements. continues as long as condition is true\
while condition:\
	output\
\
\ul For loops:\ulnone  Runs through whole list, hereunder variable_name isn\'92t defined before the for loop. That\'92s fine.\
for variable_name in list:\
	print(variable_name)\
these can be indexed: Lists with an enumerated index \
for index, variable_name in enumerate(list_name):\
print(str(index) + str(variable_name)) \
OBS: Dictionaries require method, numpy-arrays require functions to loop through, fx:\
for variable_name in np.nditer(array_name): \
\
Loops over dictionaries require .items, fx:\
for key, value in dictionary.items():\
	print(key + \'93:\'94 + value)\
\
Loops over pandas is done with iterrows() method. \
\
\
\ul Random numbers:\ulnone  Numpy. \
np.random.seed(1)\
np.random.rand() (prints random float)\
np.random.randint(0,2) (prints 0 or 1 (from 0 to but without 2))\
\
\ul Random walk: \ulnone A walk of randomness.\
Outcomes = []\
for x in range(10): \
coin = np.random.randint(0,2)\
if coin = 0:\
	Outcomes.append(0)\
else:\
	Outcomes.append(1)\
This code creates list of 10 outcomes of die toss.\
\
\
Syntaks: \
; bruges til at separere commands p\'e5 samme linje\
[ ] bruges til at indramme lister\
# Bruges til kommentarer\
\

\fs40 \

\f0\b Python for Data Science:\

\fs24 Functions: 
\f1\b0 Defined:
\f0\b \

\f1\b0 def function_name(value):\
	function_output = value * 2\
	return(function_output or something else to be outputted by function)\
function_name(2) prints out 4.\
\
\ul default parameters\ulnone : fx function_name(value, n=1). Has two parameters, value and n, of which n will be 1 by default if not changed within function\
\ul args:\ulnone  *arg as a parameter is a flexible argument. Can be added if wanted, but not necessary in function.\
\ul kwargs: \ulnone **kwargs as a parameter in functions, is a dictionary.\
\ul Scopes: \ulnone Always searched in following order: Local, Enclosing functions, Global, Built-In\ul \
\ulnone Local scope: names can only be accessed within function. Local is checked first, then global\
Global scope: Can be accessed everywhere\
	global value: sets a given value (fx defined in function) as globally given\
	nonlocal value: using value defined outside local function\
\

\f0\b Nested functions: 
\f1\b0 Function within a function. Python looks for x inside outer function first - if nothing there, it searches global scope.\

\f0\b \
Lambda functions: 
\f1\b0 quick way of writing functions. \
lambda something: this happens, from here\
\

\f0\b Iterators: 
\f1\b0 iterating over iterables (lists, dictionaries, tuples etc.)\
it = iter(word)\
next(it)\
zip(): \
list()\
\
\ul reading data in chunks:\
\ulnone df_reader = pd.read_csv('ind_pop.csv', chunksize = 10) reads data from the csv-file in chunks of size 10\
\

\f0\b List comprehensions: 
\f1\b0 Creating new lists with data from old lists, fx:\
new_data = [data + 1 for data in old_data]\
new_dict = \{key:value for data in old_data\}\
\

\f0\b Generators: \
\
Interactive figures: 
\f1\b0 following input for a figure, interactive_figure(alpha,p1,p2,k) 
\f0\b \

\f1\b0 widgets.interact(interactive_figure,\
    alphas=widgets.fixed(alphas),\
    p1=widgets.FloatSlider(description="$p_1$", min=0.1, max=5, step=0.05, value=2),\
    p2=widgets.fixed(p2),\
    k=widgets.fixed(k)\
);\
\
\
\
\
\
\
\
\
\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0
\cf2 \
\
\
}